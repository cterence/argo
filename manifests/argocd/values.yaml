argo-cd:
  server:
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true

    ingress:
      enabled: true
      annotations:
        cert-manager.io/cluster-issuer: letsencrypt
        external-dns.alpha.kubernetes.io/target: terence.cloud
        nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
        nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
        nginx.ingress.kubernetes.io/auth-url: "https://$host/oauth2/auth"
        nginx.ingress.kubernetes.io/auth-signin: "https://$host/oauth2/start?rd=$escaped_request_uri"
        nginx.ingress.kubernetes.io/auth-response-headers: X-Auth-Request-User
        nginx.ingress.kubernetes.io/configuration-snippet: |
          auth_request_set $auth_header $upstream_http_x_auth_request_user;
          proxy_set_header 'x-remote-user' $auth_header;
      pathType: ImplementationSpecific
      hosts:
        - argocd.terence.cloud
      tls:
        - secretName: argocd-tls-certificate
          hosts:
            - argocd.terence.cloud
      ingressClassName: nginx
      https: true
    config:
      url: https://argocd.terence.cloud
      # The application customization allows to do sync waves of Argo applications.
      # Very useful to counteract race conditions. Ex : deploy Prometheus operator CRDs before the kube-prometheus-stack chart
      # Or deploy nginx-ingress-controller and external-dns before cert-manager.
      # The sealed secret customization solves a constantly out of sync status for sealed secrets
      resource.customizations: |
        argoproj.io/Application:
          health.lua: |
            hs = {}
            hs.status = "Progressing"
            hs.message = ""
            if obj.status ~= nil then
              if obj.status.health ~= nil then
                hs.status = obj.status.health.status
                if obj.status.health.message ~= nil then
                  hs.message = obj.status.health.message
                end
              end
            end
            return hs
        bitnami.com/SealedSecret:
          health.lua: |
            hs = {}
            hs.status = "Healthy"
            hs.message = "Controller doesn't report resource status"
            return hs

      # Avoid out of sync loop for aggregated roles
      resource.compareoptions: |
        ignoreAggregatedRoles: true

      dex.config: |
        connectors:
          - type: authproxy
            id: oauth2-proxy
            name: OAuth2 Proxy
      admin.enabled: "false"

    rbacConfig:
      policy.default: role:admin

  configs:
    secret:
      createSecret: true
      # TODO: hide
      githubSecret: "W2iHfhnUwo0jK8vFuUZMYOwZfsXyqht8"
