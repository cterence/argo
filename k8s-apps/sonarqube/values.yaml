sonarqube:
  enabled: true
  edition: "community"
  image:
    repository: sonarqube
    tag: 10.6.0-{{ .Values.edition }}
    pullPolicy: IfNotPresent

  ingress:
    enabled: true
    hosts:
      - name: sonarqube.terence.cloud
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt
      external-dns.alpha.kubernetes.io/target: home.terence.cloud
    ingressClassName: nginx

    tls:
      - secretName: sonarqube-tls
        hosts:
          - sonarqube.terence.cloud

  initSysctl:
    enabled: false
    vmMaxMapCount: 524288
    fsFileMax: 131072
    nofile: 131072
    nproc: 8192
    # image: busybox:1.36
    securityContext:
      # Compatible with podSecurity standard privileged
      privileged: true
      # if run without root permissions, error "sysctl: permission denied on key xxx, ignoring"
      runAsUser: 0
    # resources: {}

  # This should not be required anymore, used to chown/chmod folder created by faulty CSI driver that are not applying properly POSIX fsgroup.
  initFs:
    enabled: false
    # Image: busybox:1.36
    # Compatible with podSecurity standard baseline.
    securityContext:
      privileged: false
      runAsNonRoot: false
      runAsUser: 0
      runAsGroup: 0
      seccompProfile:
        type: RuntimeDefault
      capabilities:
        drop: ["ALL"]
        add: ["CHOWN"]

  prometheusExporter:
    enabled: false
    version: "0.17.2"
    noCheckCertificate: false

    # Ports for the jmx prometheus agent to export metrics at
    webBeanPort: 8000
    ceBeanPort: 8001

    config:
      rules:
        - pattern: ".*"
    # Overrides config for the CE process Prometheus exporter (by default, the same rules are used for both the Web and CE processes).
    # ceConfig:
    #   rules:
    #     - pattern: ".*"
    # image: curlimages/curl:8.2.1
    # For use behind a corporate proxy when downloading prometheus
    # httpProxy: ""
    # httpsProxy: ""
    # noProxy: ""
    # Reuse default initcontainers.securityContext that match restricted pod security standard
    # securityContext: {}

  prometheusMonitoring:
    podMonitor:
      enabled: false
      interval: 30s

  # List of plugins to install.
  # For example:
  # plugins:
  #  install:
  #    - "https://github.com/AmadeusITGroup/sonar-stash/releases/download/1.3.0/sonar-stash-plugin-1.3.0.jar"
  #    - "https://github.com/SonarSource/sonar-ldap/releases/download/2.2-RC3/sonar-ldap-plugin-2.2.0.601.jar"
  #
  plugins:
    install: []

    # For use behind a corporate proxy when downloading plugins
    # httpProxy: ""
    # httpsProxy: ""
    # noProxy: ""

    # image: curlimages/curl:8.2.1
    # resources: {}

    # .netrc secret file with a key "netrc" to use basic auth while downloading plugins
    # netrcCreds: ""

    # Set to true to not validate the server's certificate to download plugin
    noCheckCertificate: false
    # Reuse default initcontainers.securityContext that match restricted pod security standard
    # securityContext: {}

  ## (DEPRECATED) The following value sets SONAR_WEB_JAVAOPTS (e.g., jvmOpts: "-Djava.net.preferIPv4Stack=true"). However, this is deprecated, please set SONAR_WEB_JAVAOPTS or sonar.web.javaOpts directly instead.
  jvmOpts: ""

  ## (DEPRECATED) The following value sets SONAR_CE_JAVAOPTS. However, this is deprecated, please set SONAR_CE_JAVAOPTS or sonar.ce.javaOpts directly instead.
  jvmCeOpts: ""

  ## a monitoring passcode needs to be defined in order to get reasonable probe results
  # not setting the monitoring passcode will result in a deployment that will never be ready
  monitoringPasscode: "define_it"
  # Alternatively, you can define the passcode loading it from an existing secret specifying the right key
  # monitoringPasscodeSecretName: "pass-secret-name"
  # monitoringPasscodeSecretKey: "pass-key"

  ## Environment variables to attach to the pods
  ##
  # env:
  #   # If you use a different ingress path from /, you have to add it here as the value of SONAR_WEB_CONTEXT
  #   - name: SONAR_WEB_CONTEXT
  #     value: /sonarqube
  #   - name: VARIABLE
  #     value: my-value

  # Set annotations for pods
  annotations: {}

  ## We usually don't make specific resource recommendations, as they are heavily dependend on
  ## the usage of SonarQube and the surrounding infrastructure.
  ## Those default are based on the default Web -Xmx1G -Xms128m and CE -Xmx2G -Xms128m and Search -Xmx2G -Xms2G settings of SQ sub processes
  ## Adjust these values to your needs, you can find more details on the main README of the chart.
  resources:
    limits:
      cpu: 800m
      memory: 6144M
      ephemeral-storage: 512000M
    requests:
      cpu: 400m
      memory: 2048M
      ephemeral-storage: 1536M

  persistence:
    enabled: true
    ## Set annotations on pvc
    annotations: {}

    ## Specify an existing volume claim instead of creating a new one.
    ## When using this option all following options like storageClass, accessMode and size are ignored.
    # existingClaim:

    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    storageClass:
    accessMode: ReadWriteOnce
    size: 5Gi
    uid: 1000
    guid: 0

    ## Specify extra volumes. Refer to ".spec.volumes" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    volumes: []
    ## Specify extra mounts. Refer to ".spec.containers.volumeMounts" specification : https://kubernetes.io/fr/docs/concepts/storage/volumes/
    mounts: []

  # In case you want to specify different resources for emptyDir than {}
  emptyDir: {}
    # Example of resouces that might be used:
    # medium: Memory
    # sizeLimit: 16Mi

  # A custom sonar.properties file can be provided via dictionary.
  # For example:
  # sonarProperties:
  #   sonar.forceAuthentication: true
  #   sonar.security.realm: LDAP
  #   ldap.url: ldaps://organization.com

  # Additional sonar properties to load from a secret with a key "secret.properties" (must be a string)
  # sonarSecretProperties:

  # Kubernetes secret that contains the encryption key for the sonarqube instance.
  # The secret must contain the key 'sonar-secret.txt'.
  # The 'sonar.secretKeyPath' property will be set automatically.
  # sonarSecretKey: "settings-encryption-secret"

  ## Override JDBC values
  ## for external Databases
  jdbcOverwrite:
    # If enable the JDBC Overwrite, make sure to set `postgresql.enabled=false`
    enable: true
    # The JDBC url of the external DB
    jdbcUrl: "jdbc:postgresql://sonarqube-cnpg-cluster-rw/sonarqube?socketTimeout=1500"
    # The DB user that should be used for the JDBC connection
    jdbcUsername: "sonarqube"
    # Use this if you don't mind the DB password getting stored in plain text within the values file
    # jdbcPassword: "sonarPass"
    ## Alternatively, use a pre-existing k8s secret containing the DB password
    jdbcSecretName: "sonarqube-cnpg-cluster-app"
    ## and the secretValueKey of the password found within that secret
    jdbcSecretPasswordKey: "password"

  ## (DEPRECATED) Configuration values for postgresql dependency
  ## ref: https://github.com/bitnami/charts/blob/master/bitnami/postgresql/README.md
  postgresql:
    # Enable to deploy the bitnami PostgreSQL chart
    enabled: false
    ## postgresql Chart global settings
    # global:
    #   imageRegistry: ''
    #   imagePullSecrets: ''
    ## bitnami/postgres image tag
    # image:
    #   tag: 11.7.0-debian-10-r9
    # existingSecret Name of existing secret to use for PostgreSQL passwords
    # The secret has to contain the keys postgresql-password which is the password for postgresqlUsername when it is
    # different of postgres, postgresql-postgres-password which will override postgresqlPassword,
    # postgresql-replication-password which will override replication.password and postgresql-ldap-password which will be
    # used to authenticate on LDAP. The value is evaluated as a template.
    # existingSecret: ""
    #
    # The bitnami chart enforces the key to be "postgresql-password". This value is only here for historic purposes
    # existingSecretPasswordKey: "postgresql-password"
    postgresqlUsername: "sonarUser"
    postgresqlPassword: "sonarPass"
    postgresqlDatabase: "sonarDB"
    # Specify the TCP port that PostgreSQL should use
    service:
      port: 5432
    resources:
      limits:
        cpu: 2
        memory: 2Gi
      requests:
        cpu: 100m
        memory: 200Mi
    persistence:
      enabled: true
      accessMode: ReadWriteOnce
      size: 20Gi
      storageClass:
    securityContext:
      # For standard Kubernetes deployment, set enabled=true
      # If using OpenShift, enabled=false for restricted SCC and enabled=true for anyuid/nonroot SCC
      enabled: true
      # fsGroup specification below are not applied if enabled=false. enabled=false is the required setting for OpenShift "restricted SCC" to work successfully.
      # postgresql dockerfile sets user as 1001
      fsGroup: 1001
    containerSecurityContext:
      # For standard Kubernetes deployment, set enabled=true
      # If using OpenShift, enabled=false for restricted SCC and enabled=true for anyuid/nonroot SCC
      enabled: true
      # runAsUser specification below are not applied if enabled=false. enabled=false is the required setting for OpenShift "restricted SCC" to work successfully.
      # postgresql dockerfile sets user as 1001, the rest aim at making it compatible with restricted pod security standard.
      runAsUser: 1001
      allowPrivilegeEscalation: false
      runAsNonRoot: true
      seccompProfile:
        type: RuntimeDefault
      capabilities:
        drop: ["ALL"]
    volumePermissions:
      # For standard Kubernetes deployment, set enabled=false
      # For OpenShift, set enabled=true and ensure to set volumepermissions.securitycontext.runAsUser below.
      enabled: false
      # if using restricted SCC set runAsUser: "auto" and if running under anyuid/nonroot SCC - runAsUser needs to match runAsUser above
      securityContext:
        runAsUser: 0
    shmVolume:
      chmod:
        enabled: false
    serviceAccount:
      ## If enabled = true, and name is not set, postgreSQL will create a serviceAccount
      enabled: false
      # name:

  # Additional labels to add to the pods:
  # podLabels:
  #   key: value
  podLabels: {}
  # For compatibility with 8.0 replace by "/opt/sq"
  # For compatibility with 8.2, leave the default. They changed it back to /opt/sonarqube
  sonarqubeFolder: /opt/sonarqube

  tests:
    image: ""
    enabled: true
    resources:
      requests:
        cpu: 500m
        memory: 200M
        ephemeral-storage: 100M
      limits:
        cpu: 500m
        memory: 200M
        ephemeral-storage: 1000M

  # For OpenShift set create=true to ensure service account is created.
  serviceAccount:
    create: false
    # name:
    # automountToken: false # default
    ## Annotations for the Service Account
    annotations: {}

  # extraConfig is used to load Environment Variables from Secrets and ConfigMaps
  # which may have been written by other tools, such as external orchestrators.
  #
  # These Secrets/ConfigMaps are expected to contain Key/Value pairs, such as:
  #
  # apiVersion: v1
  # kind: ConfigMap
  # metadata:
  #   name: external-sonarqube-opts
  # data:
  #   SONARQUBE_JDBC_USERNAME: foo
  #   SONARQUBE_JDBC_URL: jdbc:postgresql://db.example.com:5432/sonar
  #
  # These vars can then be injected into the environment by uncommenting the following:
  #
  # extraConfig:
  #   configmaps:
  #     - external-sonarqube-opts

  extraConfig:
    secrets: []
    configmaps: []

  # account:
  # The values can be set to define the current and the (new) custom admin passwords at the startup (the username will remain "admin")
  #   adminPassword: admin
  #   currentAdminPassword: admin
  # The above values can be also provided by a secret that contains "password" and "currentPassword" as keys. You can generate such a secret in your cluster
  # using "kubectl create secret generic admin-password-secret-name --from-literal=password=admin --from-literal=currentPassword=admin"
  #   adminPasswordSecretName: ""
  # # Reuse default initcontainers.securityContext that match restricted pod security standard
  # #   securityContext: {}
  #   resources:
  #     limits:
  #       cpu: 100m
  #       memory: 128Mi
  #     requests:
  #       cpu: 100m
  #       memory: 128Mi
  # curlContainerImage: curlimages/curl:8.2.1
  # adminJobAnnotations: {}
  # deprecated please use sonarWebContext at the value top level
  #   sonarWebContext: /

  terminationGracePeriodSeconds: 60

cnpg-cluster:
  nameOverride: ""
  fullnameOverride: ""
  # -- Type of the CNPG database. Available types:
  # * `postgresql`
  # * `postgis`
  type: postgresql

  ###
  # -- Cluster mode of operation. Available modes:
  # * `standalone` - default mode. Creates new or updates an existing CNPG cluster.
  # * `replica` - Creates a replica cluster from an existing CNPG cluster. # TODO
  # * `recovery` - Same as standalone but creates a cluster from a backup, object store or via pg_basebackup.
  mode: standalone

  cluster:
    instances: 1

    # -- Name of the container image, supporting both tags (<image>:<tag>) and digests for deterministic and repeatable deployments:
    # <image>:<tag>@sha256:<digestValue>
    imageName: "ghcr.io/cloudnative-pg/postgresql:16.3"  # Default value depends on type (postgresql/postgis/timescaledb)

    # -- Image pull policy. One of Always, Never or IfNotPresent. If not defined, it defaults to IfNotPresent. Cannot be updated.
    # More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
    imagePullPolicy: IfNotPresent

    storage:
      size: 8Gi
      storageClass: ""

    walStorage:
      size: 1Gi
      storageClass: ""

    # -- Resources requirements of every generated Pod.
    # Please refer to https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ for more information.
    # We strongly advise you use the same setting for limits and requests so that your cluster pods are given a Guaranteed QoS.
    # See: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/
    resources: {}
      # limits:
      #   cpu: 2000m
      #   memory: 8Gi
      # requests:
      #   cpu: 2000m
      #   memory: 8Gi

    # -- Method to follow to upgrade the primary server during a rolling update procedure, after all replicas have been
    # successfully updated. It can be switchover (default) or in-place (restart).
    primaryUpdateMethod: switchover

    # -- Strategy to follow to upgrade the primary server during a rolling update procedure, after all replicas have been
    # successfully updated: it can be automated (unsupervised - default) or manual (supervised)
    primaryUpdateStrategy: unsupervised

    # -- The instances' log level, one of the following values: error, warning, info (default), debug, trace
    logLevel: "info"

    # -- When this option is enabled, the operator will use the SuperuserSecret to update the postgres user password.
    # If the secret is not present, the operator will automatically create one.
    # When this option is disabled, the operator will ignore the SuperuserSecret content, delete it when automatically created,
    # and then blank the password of the postgres user by setting it to NULL.
    enableSuperuserAccess: true
    superuserSecret: ""

    # -- This feature enables declarative management of existing roles, as well as the creation of new roles if they are not
    # already present in the database.
    # See: https://cloudnative-pg.io/documentation/current/declarative_role_management/
    roles: []
      # - name: dante
      #   ensure: present
      #   login: true
      #   superuser: false
      #   inRoles:
      #     - pg_monitor
      #     - pg_signal_backend

    monitoring:
      enabled: true
      podMonitor:
        enabled: true

    # -- Configuration of the PostgreSQL server.
    # See: https://cloudnative-pg.io/documentation/current/cloudnative-pg.v1/#postgresql-cnpg-io-v1-PostgresConfiguration
    postgresql: {}
      # max_connections: 300

    # -- BootstrapInitDB is the configuration of the bootstrap process when initdb is used.
    # See: https://cloudnative-pg.io/documentation/current/bootstrap/
    # See: https://cloudnative-pg.io/documentation/current/cloudnative-pg.v1/#postgresql-cnpg-io-v1-bootstrapinitdb
    initdb:
      database: sonarqube
      # postInitSQL:
      #   - CREATE EXTENSION IF NOT EXISTS vector;
